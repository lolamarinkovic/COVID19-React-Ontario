{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _isNaN from \"lodash/isNaN\";\nimport _isString from \"lodash/isString\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport * as d3Scales from 'd3-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\nimport { isNumOrStr, uniqueId, isNumber, getPercentValue, mathSign, findEntryInArray } from './DataUtils';\nimport ReferenceDot from '../cartesian/ReferenceDot';\nimport ReferenceLine from '../cartesian/ReferenceLine';\nimport ReferenceArea from '../cartesian/ReferenceArea';\nimport ErrorBar from '../cartesian/ErrorBar';\nimport Legend from '../component/Legend';\nimport { findAllByType, findChildByType, getDisplayName } from './ReactUtils';\nexport var getValueByDataKey = function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n\n  return defaultValue;\n};\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport var getDomainOfDataByKey = function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry, 10);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData;\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) ? entry : '';\n  });\n};\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate, ticks, unsortedTicks, axis) {\n  var index = -1;\n  var len = ticks.length;\n\n  if (len > 1) {\n    if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n      var range = axis.range; // ticks are distributed in a circle\n\n      for (var i = 0; i < len; i++) {\n        var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n        var cur = unsortedTicks[i].coordinate;\n        var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n        var sameDirectionCoord = void 0;\n\n        if (mathSign(cur - before) !== mathSign(after - cur)) {\n          var diffInterval = [];\n\n          if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n            sameDirectionCoord = after;\n            var curInRange = cur + range[1] - range[0];\n            diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n            diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n          } else {\n            sameDirectionCoord = before;\n            var afterInRange = after + range[1] - range[0];\n            diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n            diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n          }\n\n          var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n\n          if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        } else {\n          var min = Math.min(before, after);\n          var max = Math.max(before, after);\n\n          if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        }\n      }\n    } else {\n      // ticks are distributed in a single direction\n      for (var _i = 0; _i < len; _i++) {\n        if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n          index = ticks[_i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    index = 0;\n  }\n\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var displayName = item.type.displayName;\n  var result;\n\n  switch (displayName) {\n    case 'Line':\n    case 'Area':\n    case 'Radar':\n      result = item.props.stroke;\n      break;\n\n    default:\n      result = item.props.fill;\n      break;\n  }\n\n  return result;\n};\nexport var getLegendProps = function getLegendProps(_ref) {\n  var children = _ref.children,\n      formatedGraphicalItems = _ref.formatedGraphicalItems,\n      legendWidth = _ref.legendWidth,\n      legendContent = _ref.legendContent;\n  var legendItem = findChildByType(children, Legend);\n\n  if (!legendItem) {\n    return null;\n  }\n\n  var legendData;\n\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formatedGraphicalItems || []).reduce(function (result, _ref2) {\n      var item = _ref2.item,\n          props = _ref2.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formatedGraphicalItems || []).map(function (_ref3) {\n      var item = _ref3.item;\n      var _item$props = item.props,\n          dataKey = _item$props.dataKey,\n          name = _item$props.name,\n          legendType = _item$props.legendType,\n          hide = _item$props.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n\n  return _objectSpread({}, legendItem.props, Legend.getWithHeight(legendItem, legendWidth), {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref4) {\n  var globalSize = _ref4.barSize,\n      _ref4$stackGroups = _ref4.stackGroups,\n      stackGroups = _ref4$stackGroups === void 0 ? {} : _ref4$stackGroups;\n\n  if (!stackGroups) {\n    return {};\n  }\n\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n          items = _sgs$stackIds$j.items,\n          cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n\n  return result;\n};\n/**\n   * Calculate the size of each bar and the gap between two bars\n   * @param  {Number} bandSize  The size of each category\n   * @param  {sizeList} sizeList  The size of all groups\n   * @param  {maxBarSize} maxBarSize The maximum size of bar\n   * @return {Number} The size of each bar and the gap between two bars\n   */\n\nexport var getBarPosition = function getBarPosition(_ref5) {\n  var barGap = _ref5.barGap,\n      barCategoryGap = _ref5.barCategoryGap,\n      bandSize = _ref5.bandSize,\n      _ref5$sizeList = _ref5.sizeList,\n      sizeList = _ref5$sizeList === void 0 ? [] : _ref5$sizeList,\n      maxBarSize = _ref5.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = _toConsumableArray(res).concat([{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n\n      prev = newRes[newRes.length - 1].position;\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = _toConsumableArray(res).concat([{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  }\n\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n      width = props.width,\n      height = props.height,\n      margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n  var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n  var legendProps = getLegendProps({\n    children: children,\n    items: items,\n    legendWidth: legendWidth,\n    legendHeight: legendHeight\n  });\n  var newOffset = offset;\n\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n        verticalAlign = legendProps.verticalAlign,\n        layout = legendProps.layout;\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _objectSpread({}, offset, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread({}, offset, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n\n  return newOffset;\n};\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {\n    var direction = errorBarChild.props.direction;\n    return _isNil(direction) || _isNil(axisType) ? true : axisType.indexOf(direction) >= 0;\n  });\n\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n\n    return result;\n  }, []);\n};\nexport var isCategorialAxis = function isCategorialAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(min);\n  }\n\n  if (!hasMax) {\n    values.push(max);\n  }\n\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n      type = axis.type,\n      range = axis.range;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / 2 : 0;\n  offset = axis.axisType === 'angleAxis' ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks setted by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  }\n\n  if (axis.isCategorial && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry),\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @return {Function}               The scale funcion\n */\n\nexport var parseScale = function parseScale(axis, chartType) {\n  var scale = axis.scale,\n      type = axis.type,\n      layout = axis.layout,\n      axisType = axis.axisType;\n\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n\n  if (_isString(scale)) {\n    var name = \"scale\".concat(scale.slice(0, 1).toUpperCase()).concat(scale.slice(1));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n\n  if (result[0] > max) {\n    result[0] = max;\n  }\n\n  if (result[1] < min) {\n    result[1] = min;\n  }\n\n  return result;\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n\n    }\n  }\n};\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props2 = item.props,\n        stackId = _item$props2.stackId,\n        hide = _item$props2.hide;\n\n    if (hide) {\n      return result;\n    }\n\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n\n    return _objectSpread({}, result, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread({}, res, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n\n    return _objectSpread({}, result, _defineProperty({}, axisId, group));\n  }, {});\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\n\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [_min(ticks), _max(ticks)];\n  }\n\n  return ticks;\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n      type = opts.type,\n      tickCount = opts.tickCount,\n      originalDomain = opts.originalDomain,\n      allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n    return {\n      niceTicks: tickValues\n    };\n  }\n\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n\n    return {\n      niceTicks: _tickValues\n    };\n  }\n\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref6) {\n  var axis = _ref6.axis,\n      ticks = _ref6.ticks,\n      bandSize = _ref6.bandSize,\n      entry = _ref6.entry,\n      index = _ref6.index,\n      dataKey = _ref6.dataKey;\n\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref7) {\n  var axis = _ref7.axis,\n      ticks = _ref7.ticks,\n      offset = _ref7.offset,\n      bandSize = _ref7.bandSize,\n      entry = _ref7.entry,\n      index = _ref7.index;\n\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref8) {\n  var numericAxis = _ref8.numericAxis;\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n\n    if (max < 0) {\n      return max;\n    }\n\n    return min;\n  }\n\n  return domain[0];\n};\nexport var ifOverflowMatches = function ifOverflowMatches(props, value) {\n  var alwaysShow = props.alwaysShow;\n  var ifOverflow = props.ifOverflow;\n\n  if (alwaysShow) {\n    ifOverflow = 'extendDomain';\n  }\n\n  return ifOverflow === value;\n};\nexport var detectReferenceElementsDomain = function detectReferenceElementsDomain(children, domain, axisId, axisType, specifiedTicks) {\n  var lines = findAllByType(children, ReferenceLine);\n  var dots = findAllByType(children, ReferenceDot);\n  var elements = lines.concat(dots);\n  var areas = findAllByType(children, ReferenceArea);\n  var idKey = \"\".concat(axisType, \"Id\");\n  var valueKey = axisType[0];\n  var finalDomain = domain;\n\n  if (elements.length) {\n    finalDomain = elements.reduce(function (result, el) {\n      if (el.props[idKey] === axisId && ifOverflowMatches(el.props, 'extendDomain') && isNumber(el.props[valueKey])) {\n        var value = el.props[valueKey];\n        return [Math.min(result[0], value), Math.max(result[1], value)];\n      }\n\n      return result;\n    }, finalDomain);\n  }\n\n  if (areas.length) {\n    var key1 = \"\".concat(valueKey, \"1\");\n    var key2 = \"\".concat(valueKey, \"2\");\n    finalDomain = areas.reduce(function (result, el) {\n      if (el.props[idKey] === axisId && ifOverflowMatches(el.props, 'extendDomain') && isNumber(el.props[key1]) && isNumber(el.props[key2])) {\n        var value1 = el.props[key1];\n        var value2 = el.props[key2];\n        return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];\n      }\n\n      return result;\n    }, finalDomain);\n  }\n\n  if (specifiedTicks && specifiedTicks.length) {\n    finalDomain = specifiedTicks.reduce(function (result, tick) {\n      if (isNumber(tick)) {\n        return [Math.min(result[0], tick), Math.max(result[1], tick)];\n      }\n\n      return result;\n    }, finalDomain);\n  }\n\n  return finalDomain;\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n\n    if (group && group.items.length) {\n      var itemIndex = -1;\n\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n\n  return null;\n};\n\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\n\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    return axis.scale.bandwidth();\n  }\n\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n\n    var bandSize = Infinity;\n\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n\n  return 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n\n  return specifiedDomain;\n};","map":{"version":3,"sources":["C:/Users/lmlol/node_modules/recharts/es6/util/ChartUtils.js"],"names":["_isEqual","_sortBy","_isNaN","_isString","_isArray","_max","_min","_flatMap","_isFunction","_get","_isNil","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_objectSpread","target","arguments","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","getNiceTickValues","getTickValuesFixedDomain","d3Scales","stack","shapeStack","stackOrderNone","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","isNumOrStr","uniqueId","isNumber","getPercentValue","mathSign","findEntryInArray","ReferenceDot","ReferenceLine","ReferenceArea","ErrorBar","Legend","findAllByType","findChildByType","getDisplayName","getValueByDataKey","dataKey","defaultValue","getDomainOfDataByKey","data","type","filterNil","flattenData","entry","domain","parseFloat","Infinity","validateData","map","calculateActiveTickIndex","coordinate","ticks","unsortedTicks","axis","index","len","axisType","Math","abs","range","before","cur","after","sameDirectionCoord","diffInterval","curInRange","min","max","afterInRange","sameInterval","_i","getMainColorOfGraphicItem","item","displayName","result","props","stroke","fill","getLegendProps","_ref","children","formatedGraphicalItems","legendWidth","legendContent","legendItem","legendData","payload","reduce","_ref2","sectors","iconType","legendType","name","color","_ref3","_item$props","hide","inactive","getWithHeight","getBarSizeList","_ref4","globalSize","barSize","_ref4$stackGroups","stackGroups","numericAxisIds","sgs","stackIds","j","sLen","_sgs$stackIds$j","items","cateAxisId","barItems","indexOf","selfSize","cateId","push","stackList","slice","getBarPosition","_ref5","barGap","barCategoryGap","bandSize","_ref5$sizeList","sizeList","maxBarSize","realBarGap","useFull","fullBarSize","sum","res","offset","prev","size","newRes","position","_offset","originalSize","appendOffsetOfLegend","legendBox","width","height","margin","left","right","legendHeight","top","bottom","legendProps","newOffset","box","align","verticalAlign","layout","getDomainOfErrorBars","errorBars","errorBarChild","direction","entryValue","mainValue","errorDomain","prevErrorArr","k","errorValue","lowerValue","upperValue","parseErrorBarsOfAxis","domains","getDomainOfItemsWithSameAxis","tag","isCategorialAxis","getCoordinatesOfGrid","hasMin","hasMax","values","getTicksOfAxis","isGrid","isAll","scale","duplicateDomain","bandwidth","niceTicks","scaleContent","isCategorial","categoricalDomain","tickCount","combineEventHandlers","defaultHandler","parentHandler","childHandler","customizedHandler","arg1","arg2","arg3","arg4","parseScale","chartType","scaleBand","realScaleType","scaleLinear","scalePoint","toUpperCase","EPS","checkDomainOfScale","first","last","findPositionOfBar","barPosition","child","truncateByDomain","offsetSign","series","n","m","positive","negative","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","stackItems","offsetType","dataKeys","d","order","getStackGroupsByAxisId","_items","numericAxisId","reverseStackOrder","reverse","_item$props2","stackId","axisId","parentGroup","hasStack","childGroup","group","g","stackedData","calculateDomainOfTicks","getTicksOfScale","opts","originalDomain","allowDecimals","scaleType","tickValues","_domain","_tickValues","getCateCoordinateOfLine","_ref6","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref7","getBaseValueOfBar","_ref8","numericAxis","ifOverflowMatches","alwaysShow","ifOverflow","detectReferenceElementsDomain","specifiedTicks","lines","dots","elements","areas","idKey","valueKey","finalDomain","el","key1","key2","value1","value2","tick","getStackedDataOfItem","itemIndex","getDomainOfSingle","getDomainOfStackGroups","startIndex","endIndex","s","MIN_VALUE_REG","MAX_VALUE_REG","parseSpecifiedDomain","specifiedDomain","dataDomain","allowDataOverflow","test","exec","_value","getBandSizeOfAxis","orderedTicks","o","parseDomainOfCategoryAxis","calculatedDomain","axisChild"],"mappings":"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","sourcesContent":["import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _isNaN from \"lodash/isNaN\";\nimport _isString from \"lodash/isString\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport * as d3Scales from 'd3-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\nimport { isNumOrStr, uniqueId, isNumber, getPercentValue, mathSign, findEntryInArray } from './DataUtils';\nimport ReferenceDot from '../cartesian/ReferenceDot';\nimport ReferenceLine from '../cartesian/ReferenceLine';\nimport ReferenceArea from '../cartesian/ReferenceArea';\nimport ErrorBar from '../cartesian/ErrorBar';\nimport Legend from '../component/Legend';\nimport { findAllByType, findChildByType, getDisplayName } from './ReactUtils';\nexport var getValueByDataKey = function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n\n  return defaultValue;\n};\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport var getDomainOfDataByKey = function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry, 10);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData;\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) ? entry : '';\n  });\n};\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate, ticks, unsortedTicks, axis) {\n  var index = -1;\n  var len = ticks.length;\n\n  if (len > 1) {\n    if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n      var range = axis.range; // ticks are distributed in a circle\n\n      for (var i = 0; i < len; i++) {\n        var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n        var cur = unsortedTicks[i].coordinate;\n        var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n        var sameDirectionCoord = void 0;\n\n        if (mathSign(cur - before) !== mathSign(after - cur)) {\n          var diffInterval = [];\n\n          if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n            sameDirectionCoord = after;\n            var curInRange = cur + range[1] - range[0];\n            diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n            diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n          } else {\n            sameDirectionCoord = before;\n            var afterInRange = after + range[1] - range[0];\n            diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n            diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n          }\n\n          var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n\n          if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        } else {\n          var min = Math.min(before, after);\n          var max = Math.max(before, after);\n\n          if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        }\n      }\n    } else {\n      // ticks are distributed in a single direction\n      for (var _i = 0; _i < len; _i++) {\n        if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n          index = ticks[_i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    index = 0;\n  }\n\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var displayName = item.type.displayName;\n  var result;\n\n  switch (displayName) {\n    case 'Line':\n    case 'Area':\n    case 'Radar':\n      result = item.props.stroke;\n      break;\n\n    default:\n      result = item.props.fill;\n      break;\n  }\n\n  return result;\n};\nexport var getLegendProps = function getLegendProps(_ref) {\n  var children = _ref.children,\n      formatedGraphicalItems = _ref.formatedGraphicalItems,\n      legendWidth = _ref.legendWidth,\n      legendContent = _ref.legendContent;\n  var legendItem = findChildByType(children, Legend);\n\n  if (!legendItem) {\n    return null;\n  }\n\n  var legendData;\n\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formatedGraphicalItems || []).reduce(function (result, _ref2) {\n      var item = _ref2.item,\n          props = _ref2.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formatedGraphicalItems || []).map(function (_ref3) {\n      var item = _ref3.item;\n      var _item$props = item.props,\n          dataKey = _item$props.dataKey,\n          name = _item$props.name,\n          legendType = _item$props.legendType,\n          hide = _item$props.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n\n  return _objectSpread({}, legendItem.props, Legend.getWithHeight(legendItem, legendWidth), {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref4) {\n  var globalSize = _ref4.barSize,\n      _ref4$stackGroups = _ref4.stackGroups,\n      stackGroups = _ref4$stackGroups === void 0 ? {} : _ref4$stackGroups;\n\n  if (!stackGroups) {\n    return {};\n  }\n\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n          items = _sgs$stackIds$j.items,\n          cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n\n  return result;\n};\n/**\n   * Calculate the size of each bar and the gap between two bars\n   * @param  {Number} bandSize  The size of each category\n   * @param  {sizeList} sizeList  The size of all groups\n   * @param  {maxBarSize} maxBarSize The maximum size of bar\n   * @return {Number} The size of each bar and the gap between two bars\n   */\n\nexport var getBarPosition = function getBarPosition(_ref5) {\n  var barGap = _ref5.barGap,\n      barCategoryGap = _ref5.barCategoryGap,\n      bandSize = _ref5.bandSize,\n      _ref5$sizeList = _ref5.sizeList,\n      sizeList = _ref5$sizeList === void 0 ? [] : _ref5$sizeList,\n      maxBarSize = _ref5.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = _toConsumableArray(res).concat([{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n\n      prev = newRes[newRes.length - 1].position;\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = _toConsumableArray(res).concat([{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  }\n\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n      width = props.width,\n      height = props.height,\n      margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n  var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n  var legendProps = getLegendProps({\n    children: children,\n    items: items,\n    legendWidth: legendWidth,\n    legendHeight: legendHeight\n  });\n  var newOffset = offset;\n\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n        verticalAlign = legendProps.verticalAlign,\n        layout = legendProps.layout;\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _objectSpread({}, offset, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread({}, offset, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n\n  return newOffset;\n};\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {\n    var direction = errorBarChild.props.direction;\n    return _isNil(direction) || _isNil(axisType) ? true : axisType.indexOf(direction) >= 0;\n  });\n\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n\n    return result;\n  }, []);\n};\nexport var isCategorialAxis = function isCategorialAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(min);\n  }\n\n  if (!hasMax) {\n    values.push(max);\n  }\n\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n      type = axis.type,\n      range = axis.range;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / 2 : 0;\n  offset = axis.axisType === 'angleAxis' ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks setted by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  }\n\n  if (axis.isCategorial && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry),\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @return {Function}               The scale funcion\n */\n\nexport var parseScale = function parseScale(axis, chartType) {\n  var scale = axis.scale,\n      type = axis.type,\n      layout = axis.layout,\n      axisType = axis.axisType;\n\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n\n  if (_isString(scale)) {\n    var name = \"scale\".concat(scale.slice(0, 1).toUpperCase()).concat(scale.slice(1));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n\n  if (result[0] > max) {\n    result[0] = max;\n  }\n\n  if (result[1] < min) {\n    result[1] = min;\n  }\n\n  return result;\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n\n    }\n  }\n};\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props2 = item.props,\n        stackId = _item$props2.stackId,\n        hide = _item$props2.hide;\n\n    if (hide) {\n      return result;\n    }\n\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n\n    return _objectSpread({}, result, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread({}, res, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n\n    return _objectSpread({}, result, _defineProperty({}, axisId, group));\n  }, {});\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\n\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [_min(ticks), _max(ticks)];\n  }\n\n  return ticks;\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n      type = opts.type,\n      tickCount = opts.tickCount,\n      originalDomain = opts.originalDomain,\n      allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n    return {\n      niceTicks: tickValues\n    };\n  }\n\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n\n    return {\n      niceTicks: _tickValues\n    };\n  }\n\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref6) {\n  var axis = _ref6.axis,\n      ticks = _ref6.ticks,\n      bandSize = _ref6.bandSize,\n      entry = _ref6.entry,\n      index = _ref6.index,\n      dataKey = _ref6.dataKey;\n\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref7) {\n  var axis = _ref7.axis,\n      ticks = _ref7.ticks,\n      offset = _ref7.offset,\n      bandSize = _ref7.bandSize,\n      entry = _ref7.entry,\n      index = _ref7.index;\n\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref8) {\n  var numericAxis = _ref8.numericAxis;\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n\n    if (max < 0) {\n      return max;\n    }\n\n    return min;\n  }\n\n  return domain[0];\n};\nexport var ifOverflowMatches = function ifOverflowMatches(props, value) {\n  var alwaysShow = props.alwaysShow;\n  var ifOverflow = props.ifOverflow;\n\n  if (alwaysShow) {\n    ifOverflow = 'extendDomain';\n  }\n\n  return ifOverflow === value;\n};\nexport var detectReferenceElementsDomain = function detectReferenceElementsDomain(children, domain, axisId, axisType, specifiedTicks) {\n  var lines = findAllByType(children, ReferenceLine);\n  var dots = findAllByType(children, ReferenceDot);\n  var elements = lines.concat(dots);\n  var areas = findAllByType(children, ReferenceArea);\n  var idKey = \"\".concat(axisType, \"Id\");\n  var valueKey = axisType[0];\n  var finalDomain = domain;\n\n  if (elements.length) {\n    finalDomain = elements.reduce(function (result, el) {\n      if (el.props[idKey] === axisId && ifOverflowMatches(el.props, 'extendDomain') && isNumber(el.props[valueKey])) {\n        var value = el.props[valueKey];\n        return [Math.min(result[0], value), Math.max(result[1], value)];\n      }\n\n      return result;\n    }, finalDomain);\n  }\n\n  if (areas.length) {\n    var key1 = \"\".concat(valueKey, \"1\");\n    var key2 = \"\".concat(valueKey, \"2\");\n    finalDomain = areas.reduce(function (result, el) {\n      if (el.props[idKey] === axisId && ifOverflowMatches(el.props, 'extendDomain') && isNumber(el.props[key1]) && isNumber(el.props[key2])) {\n        var value1 = el.props[key1];\n        var value2 = el.props[key2];\n        return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];\n      }\n\n      return result;\n    }, finalDomain);\n  }\n\n  if (specifiedTicks && specifiedTicks.length) {\n    finalDomain = specifiedTicks.reduce(function (result, tick) {\n      if (isNumber(tick)) {\n        return [Math.min(result[0], tick), Math.max(result[1], tick)];\n      }\n\n      return result;\n    }, finalDomain);\n  }\n\n  return finalDomain;\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n\n    if (group && group.items.length) {\n      var itemIndex = -1;\n\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n\n  return null;\n};\n\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\n\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    return axis.scale.bandwidth();\n  }\n\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n\n    var bandSize = Infinity;\n\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n\n  return 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n\n  return specifiedDomain;\n};"]},"metadata":{},"sourceType":"module"}